// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trojangoapi.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_trojangoapi_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_trojangoapi_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_trojangoapi_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_trojangoapi_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_trojangoapi_2eproto;
namespace trojan {
namespace api {
class GetTrafficRequest;
class GetTrafficRequestDefaultTypeInternal;
extern GetTrafficRequestDefaultTypeInternal _GetTrafficRequest_default_instance_;
class GetTrafficResponse;
class GetTrafficResponseDefaultTypeInternal;
extern GetTrafficResponseDefaultTypeInternal _GetTrafficResponse_default_instance_;
class GetUsersRequest;
class GetUsersRequestDefaultTypeInternal;
extern GetUsersRequestDefaultTypeInternal _GetUsersRequest_default_instance_;
class GetUsersResponse;
class GetUsersResponseDefaultTypeInternal;
extern GetUsersResponseDefaultTypeInternal _GetUsersResponse_default_instance_;
class ListUsersRequest;
class ListUsersRequestDefaultTypeInternal;
extern ListUsersRequestDefaultTypeInternal _ListUsersRequest_default_instance_;
class ListUsersResponse;
class ListUsersResponseDefaultTypeInternal;
extern ListUsersResponseDefaultTypeInternal _ListUsersResponse_default_instance_;
class SetUsersRequest;
class SetUsersRequestDefaultTypeInternal;
extern SetUsersRequestDefaultTypeInternal _SetUsersRequest_default_instance_;
class SetUsersResponse;
class SetUsersResponseDefaultTypeInternal;
extern SetUsersResponseDefaultTypeInternal _SetUsersResponse_default_instance_;
class Speed;
class SpeedDefaultTypeInternal;
extern SpeedDefaultTypeInternal _Speed_default_instance_;
class Traffic;
class TrafficDefaultTypeInternal;
extern TrafficDefaultTypeInternal _Traffic_default_instance_;
class User;
class UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class UserStatus;
class UserStatusDefaultTypeInternal;
extern UserStatusDefaultTypeInternal _UserStatus_default_instance_;
}  // namespace api
}  // namespace trojan
PROTOBUF_NAMESPACE_OPEN
template<> ::trojan::api::GetTrafficRequest* Arena::CreateMaybeMessage<::trojan::api::GetTrafficRequest>(Arena*);
template<> ::trojan::api::GetTrafficResponse* Arena::CreateMaybeMessage<::trojan::api::GetTrafficResponse>(Arena*);
template<> ::trojan::api::GetUsersRequest* Arena::CreateMaybeMessage<::trojan::api::GetUsersRequest>(Arena*);
template<> ::trojan::api::GetUsersResponse* Arena::CreateMaybeMessage<::trojan::api::GetUsersResponse>(Arena*);
template<> ::trojan::api::ListUsersRequest* Arena::CreateMaybeMessage<::trojan::api::ListUsersRequest>(Arena*);
template<> ::trojan::api::ListUsersResponse* Arena::CreateMaybeMessage<::trojan::api::ListUsersResponse>(Arena*);
template<> ::trojan::api::SetUsersRequest* Arena::CreateMaybeMessage<::trojan::api::SetUsersRequest>(Arena*);
template<> ::trojan::api::SetUsersResponse* Arena::CreateMaybeMessage<::trojan::api::SetUsersResponse>(Arena*);
template<> ::trojan::api::Speed* Arena::CreateMaybeMessage<::trojan::api::Speed>(Arena*);
template<> ::trojan::api::Traffic* Arena::CreateMaybeMessage<::trojan::api::Traffic>(Arena*);
template<> ::trojan::api::User* Arena::CreateMaybeMessage<::trojan::api::User>(Arena*);
template<> ::trojan::api::UserStatus* Arena::CreateMaybeMessage<::trojan::api::UserStatus>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace trojan {
namespace api {

enum SetUsersRequest_Operation : int {
  SetUsersRequest_Operation_Add = 0,
  SetUsersRequest_Operation_Delete = 1,
  SetUsersRequest_Operation_Modify = 2,
  SetUsersRequest_Operation_SetUsersRequest_Operation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SetUsersRequest_Operation_SetUsersRequest_Operation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SetUsersRequest_Operation_IsValid(int value);
constexpr SetUsersRequest_Operation SetUsersRequest_Operation_Operation_MIN = SetUsersRequest_Operation_Add;
constexpr SetUsersRequest_Operation SetUsersRequest_Operation_Operation_MAX = SetUsersRequest_Operation_Modify;
constexpr int SetUsersRequest_Operation_Operation_ARRAYSIZE = SetUsersRequest_Operation_Operation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SetUsersRequest_Operation_descriptor();
template<typename T>
inline const std::string& SetUsersRequest_Operation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SetUsersRequest_Operation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SetUsersRequest_Operation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SetUsersRequest_Operation_descriptor(), enum_t_value);
}
inline bool SetUsersRequest_Operation_Parse(
    const std::string& name, SetUsersRequest_Operation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SetUsersRequest_Operation>(
    SetUsersRequest_Operation_descriptor(), name, value);
}
// ===================================================================

class Traffic PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trojan.api.Traffic) */ {
 public:
  inline Traffic() : Traffic(nullptr) {};
  virtual ~Traffic();

  Traffic(const Traffic& from);
  Traffic(Traffic&& from) noexcept
    : Traffic() {
    *this = ::std::move(from);
  }

  inline Traffic& operator=(const Traffic& from) {
    CopyFrom(from);
    return *this;
  }
  inline Traffic& operator=(Traffic&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Traffic& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Traffic* internal_default_instance() {
    return reinterpret_cast<const Traffic*>(
               &_Traffic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Traffic& a, Traffic& b) {
    a.Swap(&b);
  }
  inline void Swap(Traffic* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Traffic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Traffic* New() const final {
    return CreateMaybeMessage<Traffic>(nullptr);
  }

  Traffic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Traffic>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Traffic& from);
  void MergeFrom(const Traffic& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Traffic* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trojan.api.Traffic";
  }
  protected:
  explicit Traffic(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trojangoapi_2eproto);
    return ::descriptor_table_trojangoapi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUploadTrafficFieldNumber = 1,
    kDownloadTrafficFieldNumber = 2,
  };
  // uint64 upload_traffic = 1;
  void clear_upload_traffic();
  ::PROTOBUF_NAMESPACE_ID::uint64 upload_traffic() const;
  void set_upload_traffic(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_upload_traffic() const;
  void _internal_set_upload_traffic(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 download_traffic = 2;
  void clear_download_traffic();
  ::PROTOBUF_NAMESPACE_ID::uint64 download_traffic() const;
  void set_download_traffic(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_download_traffic() const;
  void _internal_set_download_traffic(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:trojan.api.Traffic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 upload_traffic_;
  ::PROTOBUF_NAMESPACE_ID::uint64 download_traffic_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trojangoapi_2eproto;
};
// -------------------------------------------------------------------

class Speed PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trojan.api.Speed) */ {
 public:
  inline Speed() : Speed(nullptr) {};
  virtual ~Speed();

  Speed(const Speed& from);
  Speed(Speed&& from) noexcept
    : Speed() {
    *this = ::std::move(from);
  }

  inline Speed& operator=(const Speed& from) {
    CopyFrom(from);
    return *this;
  }
  inline Speed& operator=(Speed&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Speed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Speed* internal_default_instance() {
    return reinterpret_cast<const Speed*>(
               &_Speed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Speed& a, Speed& b) {
    a.Swap(&b);
  }
  inline void Swap(Speed* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Speed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Speed* New() const final {
    return CreateMaybeMessage<Speed>(nullptr);
  }

  Speed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Speed>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Speed& from);
  void MergeFrom(const Speed& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Speed* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trojan.api.Speed";
  }
  protected:
  explicit Speed(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trojangoapi_2eproto);
    return ::descriptor_table_trojangoapi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUploadSpeedFieldNumber = 1,
    kDownloadSpeedFieldNumber = 2,
  };
  // uint64 upload_speed = 1;
  void clear_upload_speed();
  ::PROTOBUF_NAMESPACE_ID::uint64 upload_speed() const;
  void set_upload_speed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_upload_speed() const;
  void _internal_set_upload_speed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 download_speed = 2;
  void clear_download_speed();
  ::PROTOBUF_NAMESPACE_ID::uint64 download_speed() const;
  void set_download_speed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_download_speed() const;
  void _internal_set_download_speed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:trojan.api.Speed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 upload_speed_;
  ::PROTOBUF_NAMESPACE_ID::uint64 download_speed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trojangoapi_2eproto;
};
// -------------------------------------------------------------------

class User PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trojan.api.User) */ {
 public:
  inline User() : User(nullptr) {};
  virtual ~User();

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const User& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline User* New() const final {
    return CreateMaybeMessage<User>(nullptr);
  }

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<User>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trojan.api.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trojangoapi_2eproto);
    return ::descriptor_table_trojangoapi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasswordFieldNumber = 1,
    kHashFieldNumber = 2,
  };
  // string password = 1;
  void clear_password();
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_password();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_password(
      std::string* password);
  private:
  const std::string& _internal_password() const;
  void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string hash = 2;
  void clear_hash();
  const std::string& hash() const;
  void set_hash(const std::string& value);
  void set_hash(std::string&& value);
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  std::string* mutable_hash();
  std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_hash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_hash(
      std::string* hash);
  private:
  const std::string& _internal_hash() const;
  void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // @@protoc_insertion_point(class_scope:trojan.api.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trojangoapi_2eproto;
};
// -------------------------------------------------------------------

class UserStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trojan.api.UserStatus) */ {
 public:
  inline UserStatus() : UserStatus(nullptr) {};
  virtual ~UserStatus();

  UserStatus(const UserStatus& from);
  UserStatus(UserStatus&& from) noexcept
    : UserStatus() {
    *this = ::std::move(from);
  }

  inline UserStatus& operator=(const UserStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserStatus& operator=(UserStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UserStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserStatus* internal_default_instance() {
    return reinterpret_cast<const UserStatus*>(
               &_UserStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UserStatus& a, UserStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(UserStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserStatus* New() const final {
    return CreateMaybeMessage<UserStatus>(nullptr);
  }

  UserStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserStatus& from);
  void MergeFrom(const UserStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trojan.api.UserStatus";
  }
  protected:
  explicit UserStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trojangoapi_2eproto);
    return ::descriptor_table_trojangoapi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kTrafficTotalFieldNumber = 2,
    kSpeedCurrentFieldNumber = 3,
    kSpeedLimitFieldNumber = 4,
    kIpCurrentFieldNumber = 5,
    kIpLimitFieldNumber = 6,
  };
  // .trojan.api.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::trojan::api::User& user() const;
  ::trojan::api::User* release_user();
  ::trojan::api::User* mutable_user();
  void set_allocated_user(::trojan::api::User* user);
  private:
  const ::trojan::api::User& _internal_user() const;
  ::trojan::api::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::trojan::api::User* user);
  ::trojan::api::User* unsafe_arena_release_user();

  // .trojan.api.Traffic traffic_total = 2;
  bool has_traffic_total() const;
  private:
  bool _internal_has_traffic_total() const;
  public:
  void clear_traffic_total();
  const ::trojan::api::Traffic& traffic_total() const;
  ::trojan::api::Traffic* release_traffic_total();
  ::trojan::api::Traffic* mutable_traffic_total();
  void set_allocated_traffic_total(::trojan::api::Traffic* traffic_total);
  private:
  const ::trojan::api::Traffic& _internal_traffic_total() const;
  ::trojan::api::Traffic* _internal_mutable_traffic_total();
  public:
  void unsafe_arena_set_allocated_traffic_total(
      ::trojan::api::Traffic* traffic_total);
  ::trojan::api::Traffic* unsafe_arena_release_traffic_total();

  // .trojan.api.Speed speed_current = 3;
  bool has_speed_current() const;
  private:
  bool _internal_has_speed_current() const;
  public:
  void clear_speed_current();
  const ::trojan::api::Speed& speed_current() const;
  ::trojan::api::Speed* release_speed_current();
  ::trojan::api::Speed* mutable_speed_current();
  void set_allocated_speed_current(::trojan::api::Speed* speed_current);
  private:
  const ::trojan::api::Speed& _internal_speed_current() const;
  ::trojan::api::Speed* _internal_mutable_speed_current();
  public:
  void unsafe_arena_set_allocated_speed_current(
      ::trojan::api::Speed* speed_current);
  ::trojan::api::Speed* unsafe_arena_release_speed_current();

  // .trojan.api.Speed speed_limit = 4;
  bool has_speed_limit() const;
  private:
  bool _internal_has_speed_limit() const;
  public:
  void clear_speed_limit();
  const ::trojan::api::Speed& speed_limit() const;
  ::trojan::api::Speed* release_speed_limit();
  ::trojan::api::Speed* mutable_speed_limit();
  void set_allocated_speed_limit(::trojan::api::Speed* speed_limit);
  private:
  const ::trojan::api::Speed& _internal_speed_limit() const;
  ::trojan::api::Speed* _internal_mutable_speed_limit();
  public:
  void unsafe_arena_set_allocated_speed_limit(
      ::trojan::api::Speed* speed_limit);
  ::trojan::api::Speed* unsafe_arena_release_speed_limit();

  // int32 ip_current = 5;
  void clear_ip_current();
  ::PROTOBUF_NAMESPACE_ID::int32 ip_current() const;
  void set_ip_current(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ip_current() const;
  void _internal_set_ip_current(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 ip_limit = 6;
  void clear_ip_limit();
  ::PROTOBUF_NAMESPACE_ID::int32 ip_limit() const;
  void set_ip_limit(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ip_limit() const;
  void _internal_set_ip_limit(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:trojan.api.UserStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::trojan::api::User* user_;
  ::trojan::api::Traffic* traffic_total_;
  ::trojan::api::Speed* speed_current_;
  ::trojan::api::Speed* speed_limit_;
  ::PROTOBUF_NAMESPACE_ID::int32 ip_current_;
  ::PROTOBUF_NAMESPACE_ID::int32 ip_limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trojangoapi_2eproto;
};
// -------------------------------------------------------------------

class GetTrafficRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trojan.api.GetTrafficRequest) */ {
 public:
  inline GetTrafficRequest() : GetTrafficRequest(nullptr) {};
  virtual ~GetTrafficRequest();

  GetTrafficRequest(const GetTrafficRequest& from);
  GetTrafficRequest(GetTrafficRequest&& from) noexcept
    : GetTrafficRequest() {
    *this = ::std::move(from);
  }

  inline GetTrafficRequest& operator=(const GetTrafficRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTrafficRequest& operator=(GetTrafficRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetTrafficRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTrafficRequest* internal_default_instance() {
    return reinterpret_cast<const GetTrafficRequest*>(
               &_GetTrafficRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetTrafficRequest& a, GetTrafficRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTrafficRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTrafficRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTrafficRequest* New() const final {
    return CreateMaybeMessage<GetTrafficRequest>(nullptr);
  }

  GetTrafficRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTrafficRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetTrafficRequest& from);
  void MergeFrom(const GetTrafficRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTrafficRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trojan.api.GetTrafficRequest";
  }
  protected:
  explicit GetTrafficRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trojangoapi_2eproto);
    return ::descriptor_table_trojangoapi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .trojan.api.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::trojan::api::User& user() const;
  ::trojan::api::User* release_user();
  ::trojan::api::User* mutable_user();
  void set_allocated_user(::trojan::api::User* user);
  private:
  const ::trojan::api::User& _internal_user() const;
  ::trojan::api::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::trojan::api::User* user);
  ::trojan::api::User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:trojan.api.GetTrafficRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::trojan::api::User* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trojangoapi_2eproto;
};
// -------------------------------------------------------------------

class GetTrafficResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trojan.api.GetTrafficResponse) */ {
 public:
  inline GetTrafficResponse() : GetTrafficResponse(nullptr) {};
  virtual ~GetTrafficResponse();

  GetTrafficResponse(const GetTrafficResponse& from);
  GetTrafficResponse(GetTrafficResponse&& from) noexcept
    : GetTrafficResponse() {
    *this = ::std::move(from);
  }

  inline GetTrafficResponse& operator=(const GetTrafficResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTrafficResponse& operator=(GetTrafficResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetTrafficResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTrafficResponse* internal_default_instance() {
    return reinterpret_cast<const GetTrafficResponse*>(
               &_GetTrafficResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetTrafficResponse& a, GetTrafficResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTrafficResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTrafficResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTrafficResponse* New() const final {
    return CreateMaybeMessage<GetTrafficResponse>(nullptr);
  }

  GetTrafficResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTrafficResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetTrafficResponse& from);
  void MergeFrom(const GetTrafficResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTrafficResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trojan.api.GetTrafficResponse";
  }
  protected:
  explicit GetTrafficResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trojangoapi_2eproto);
    return ::descriptor_table_trojangoapi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 2,
    kTrafficTotalFieldNumber = 3,
    kSpeedCurrentFieldNumber = 4,
    kSuccessFieldNumber = 1,
  };
  // string info = 2;
  void clear_info();
  const std::string& info() const;
  void set_info(const std::string& value);
  void set_info(std::string&& value);
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  std::string* mutable_info();
  std::string* release_info();
  void set_allocated_info(std::string* info);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_info();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_info(
      std::string* info);
  private:
  const std::string& _internal_info() const;
  void _internal_set_info(const std::string& value);
  std::string* _internal_mutable_info();
  public:

  // .trojan.api.Traffic traffic_total = 3;
  bool has_traffic_total() const;
  private:
  bool _internal_has_traffic_total() const;
  public:
  void clear_traffic_total();
  const ::trojan::api::Traffic& traffic_total() const;
  ::trojan::api::Traffic* release_traffic_total();
  ::trojan::api::Traffic* mutable_traffic_total();
  void set_allocated_traffic_total(::trojan::api::Traffic* traffic_total);
  private:
  const ::trojan::api::Traffic& _internal_traffic_total() const;
  ::trojan::api::Traffic* _internal_mutable_traffic_total();
  public:
  void unsafe_arena_set_allocated_traffic_total(
      ::trojan::api::Traffic* traffic_total);
  ::trojan::api::Traffic* unsafe_arena_release_traffic_total();

  // .trojan.api.Speed speed_current = 4;
  bool has_speed_current() const;
  private:
  bool _internal_has_speed_current() const;
  public:
  void clear_speed_current();
  const ::trojan::api::Speed& speed_current() const;
  ::trojan::api::Speed* release_speed_current();
  ::trojan::api::Speed* mutable_speed_current();
  void set_allocated_speed_current(::trojan::api::Speed* speed_current);
  private:
  const ::trojan::api::Speed& _internal_speed_current() const;
  ::trojan::api::Speed* _internal_mutable_speed_current();
  public:
  void unsafe_arena_set_allocated_speed_current(
      ::trojan::api::Speed* speed_current);
  ::trojan::api::Speed* unsafe_arena_release_speed_current();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:trojan.api.GetTrafficResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
  ::trojan::api::Traffic* traffic_total_;
  ::trojan::api::Speed* speed_current_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trojangoapi_2eproto;
};
// -------------------------------------------------------------------

class ListUsersRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trojan.api.ListUsersRequest) */ {
 public:
  inline ListUsersRequest() : ListUsersRequest(nullptr) {};
  virtual ~ListUsersRequest();

  ListUsersRequest(const ListUsersRequest& from);
  ListUsersRequest(ListUsersRequest&& from) noexcept
    : ListUsersRequest() {
    *this = ::std::move(from);
  }

  inline ListUsersRequest& operator=(const ListUsersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListUsersRequest& operator=(ListUsersRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListUsersRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListUsersRequest* internal_default_instance() {
    return reinterpret_cast<const ListUsersRequest*>(
               &_ListUsersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ListUsersRequest& a, ListUsersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListUsersRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListUsersRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListUsersRequest* New() const final {
    return CreateMaybeMessage<ListUsersRequest>(nullptr);
  }

  ListUsersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListUsersRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListUsersRequest& from);
  void MergeFrom(const ListUsersRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListUsersRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trojan.api.ListUsersRequest";
  }
  protected:
  explicit ListUsersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trojangoapi_2eproto);
    return ::descriptor_table_trojangoapi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:trojan.api.ListUsersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trojangoapi_2eproto;
};
// -------------------------------------------------------------------

class ListUsersResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trojan.api.ListUsersResponse) */ {
 public:
  inline ListUsersResponse() : ListUsersResponse(nullptr) {};
  virtual ~ListUsersResponse();

  ListUsersResponse(const ListUsersResponse& from);
  ListUsersResponse(ListUsersResponse&& from) noexcept
    : ListUsersResponse() {
    *this = ::std::move(from);
  }

  inline ListUsersResponse& operator=(const ListUsersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListUsersResponse& operator=(ListUsersResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListUsersResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListUsersResponse* internal_default_instance() {
    return reinterpret_cast<const ListUsersResponse*>(
               &_ListUsersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ListUsersResponse& a, ListUsersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListUsersResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListUsersResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListUsersResponse* New() const final {
    return CreateMaybeMessage<ListUsersResponse>(nullptr);
  }

  ListUsersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListUsersResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListUsersResponse& from);
  void MergeFrom(const ListUsersResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListUsersResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trojan.api.ListUsersResponse";
  }
  protected:
  explicit ListUsersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trojangoapi_2eproto);
    return ::descriptor_table_trojangoapi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .trojan.api.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::trojan::api::User& user() const;
  ::trojan::api::User* release_user();
  ::trojan::api::User* mutable_user();
  void set_allocated_user(::trojan::api::User* user);
  private:
  const ::trojan::api::User& _internal_user() const;
  ::trojan::api::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::trojan::api::User* user);
  ::trojan::api::User* unsafe_arena_release_user();

  // .trojan.api.UserStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::trojan::api::UserStatus& status() const;
  ::trojan::api::UserStatus* release_status();
  ::trojan::api::UserStatus* mutable_status();
  void set_allocated_status(::trojan::api::UserStatus* status);
  private:
  const ::trojan::api::UserStatus& _internal_status() const;
  ::trojan::api::UserStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::trojan::api::UserStatus* status);
  ::trojan::api::UserStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:trojan.api.ListUsersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::trojan::api::User* user_;
  ::trojan::api::UserStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trojangoapi_2eproto;
};
// -------------------------------------------------------------------

class GetUsersRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trojan.api.GetUsersRequest) */ {
 public:
  inline GetUsersRequest() : GetUsersRequest(nullptr) {};
  virtual ~GetUsersRequest();

  GetUsersRequest(const GetUsersRequest& from);
  GetUsersRequest(GetUsersRequest&& from) noexcept
    : GetUsersRequest() {
    *this = ::std::move(from);
  }

  inline GetUsersRequest& operator=(const GetUsersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUsersRequest& operator=(GetUsersRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetUsersRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetUsersRequest* internal_default_instance() {
    return reinterpret_cast<const GetUsersRequest*>(
               &_GetUsersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetUsersRequest& a, GetUsersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUsersRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUsersRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetUsersRequest* New() const final {
    return CreateMaybeMessage<GetUsersRequest>(nullptr);
  }

  GetUsersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetUsersRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetUsersRequest& from);
  void MergeFrom(const GetUsersRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUsersRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trojan.api.GetUsersRequest";
  }
  protected:
  explicit GetUsersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trojangoapi_2eproto);
    return ::descriptor_table_trojangoapi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .trojan.api.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::trojan::api::User& user() const;
  ::trojan::api::User* release_user();
  ::trojan::api::User* mutable_user();
  void set_allocated_user(::trojan::api::User* user);
  private:
  const ::trojan::api::User& _internal_user() const;
  ::trojan::api::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::trojan::api::User* user);
  ::trojan::api::User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:trojan.api.GetUsersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::trojan::api::User* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trojangoapi_2eproto;
};
// -------------------------------------------------------------------

class GetUsersResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trojan.api.GetUsersResponse) */ {
 public:
  inline GetUsersResponse() : GetUsersResponse(nullptr) {};
  virtual ~GetUsersResponse();

  GetUsersResponse(const GetUsersResponse& from);
  GetUsersResponse(GetUsersResponse&& from) noexcept
    : GetUsersResponse() {
    *this = ::std::move(from);
  }

  inline GetUsersResponse& operator=(const GetUsersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUsersResponse& operator=(GetUsersResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetUsersResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetUsersResponse* internal_default_instance() {
    return reinterpret_cast<const GetUsersResponse*>(
               &_GetUsersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetUsersResponse& a, GetUsersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUsersResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUsersResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetUsersResponse* New() const final {
    return CreateMaybeMessage<GetUsersResponse>(nullptr);
  }

  GetUsersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetUsersResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetUsersResponse& from);
  void MergeFrom(const GetUsersResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUsersResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trojan.api.GetUsersResponse";
  }
  protected:
  explicit GetUsersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trojangoapi_2eproto);
    return ::descriptor_table_trojangoapi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 2,
    kUserFieldNumber = 3,
    kStatusFieldNumber = 4,
    kSuccessFieldNumber = 1,
  };
  // string info = 2;
  void clear_info();
  const std::string& info() const;
  void set_info(const std::string& value);
  void set_info(std::string&& value);
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  std::string* mutable_info();
  std::string* release_info();
  void set_allocated_info(std::string* info);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_info();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_info(
      std::string* info);
  private:
  const std::string& _internal_info() const;
  void _internal_set_info(const std::string& value);
  std::string* _internal_mutable_info();
  public:

  // .trojan.api.User user = 3;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::trojan::api::User& user() const;
  ::trojan::api::User* release_user();
  ::trojan::api::User* mutable_user();
  void set_allocated_user(::trojan::api::User* user);
  private:
  const ::trojan::api::User& _internal_user() const;
  ::trojan::api::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::trojan::api::User* user);
  ::trojan::api::User* unsafe_arena_release_user();

  // .trojan.api.UserStatus status = 4;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::trojan::api::UserStatus& status() const;
  ::trojan::api::UserStatus* release_status();
  ::trojan::api::UserStatus* mutable_status();
  void set_allocated_status(::trojan::api::UserStatus* status);
  private:
  const ::trojan::api::UserStatus& _internal_status() const;
  ::trojan::api::UserStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::trojan::api::UserStatus* status);
  ::trojan::api::UserStatus* unsafe_arena_release_status();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:trojan.api.GetUsersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
  ::trojan::api::User* user_;
  ::trojan::api::UserStatus* status_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trojangoapi_2eproto;
};
// -------------------------------------------------------------------

class SetUsersRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trojan.api.SetUsersRequest) */ {
 public:
  inline SetUsersRequest() : SetUsersRequest(nullptr) {};
  virtual ~SetUsersRequest();

  SetUsersRequest(const SetUsersRequest& from);
  SetUsersRequest(SetUsersRequest&& from) noexcept
    : SetUsersRequest() {
    *this = ::std::move(from);
  }

  inline SetUsersRequest& operator=(const SetUsersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetUsersRequest& operator=(SetUsersRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetUsersRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetUsersRequest* internal_default_instance() {
    return reinterpret_cast<const SetUsersRequest*>(
               &_SetUsersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SetUsersRequest& a, SetUsersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetUsersRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetUsersRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetUsersRequest* New() const final {
    return CreateMaybeMessage<SetUsersRequest>(nullptr);
  }

  SetUsersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetUsersRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetUsersRequest& from);
  void MergeFrom(const SetUsersRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetUsersRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trojan.api.SetUsersRequest";
  }
  protected:
  explicit SetUsersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trojangoapi_2eproto);
    return ::descriptor_table_trojangoapi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef SetUsersRequest_Operation Operation;
  static constexpr Operation Add =
    SetUsersRequest_Operation_Add;
  static constexpr Operation Delete =
    SetUsersRequest_Operation_Delete;
  static constexpr Operation Modify =
    SetUsersRequest_Operation_Modify;
  static inline bool Operation_IsValid(int value) {
    return SetUsersRequest_Operation_IsValid(value);
  }
  static constexpr Operation Operation_MIN =
    SetUsersRequest_Operation_Operation_MIN;
  static constexpr Operation Operation_MAX =
    SetUsersRequest_Operation_Operation_MAX;
  static constexpr int Operation_ARRAYSIZE =
    SetUsersRequest_Operation_Operation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Operation_descriptor() {
    return SetUsersRequest_Operation_descriptor();
  }
  template<typename T>
  static inline const std::string& Operation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Operation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Operation_Name.");
    return SetUsersRequest_Operation_Name(enum_t_value);
  }
  static inline bool Operation_Parse(const std::string& name,
      Operation* value) {
    return SetUsersRequest_Operation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kSpeedLimitFieldNumber = 3,
    kOperationFieldNumber = 2,
    kIpLimitFieldNumber = 4,
  };
  // .trojan.api.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::trojan::api::User& user() const;
  ::trojan::api::User* release_user();
  ::trojan::api::User* mutable_user();
  void set_allocated_user(::trojan::api::User* user);
  private:
  const ::trojan::api::User& _internal_user() const;
  ::trojan::api::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::trojan::api::User* user);
  ::trojan::api::User* unsafe_arena_release_user();

  // .trojan.api.Speed speed_limit = 3;
  bool has_speed_limit() const;
  private:
  bool _internal_has_speed_limit() const;
  public:
  void clear_speed_limit();
  const ::trojan::api::Speed& speed_limit() const;
  ::trojan::api::Speed* release_speed_limit();
  ::trojan::api::Speed* mutable_speed_limit();
  void set_allocated_speed_limit(::trojan::api::Speed* speed_limit);
  private:
  const ::trojan::api::Speed& _internal_speed_limit() const;
  ::trojan::api::Speed* _internal_mutable_speed_limit();
  public:
  void unsafe_arena_set_allocated_speed_limit(
      ::trojan::api::Speed* speed_limit);
  ::trojan::api::Speed* unsafe_arena_release_speed_limit();

  // .trojan.api.SetUsersRequest.Operation operation = 2;
  void clear_operation();
  ::trojan::api::SetUsersRequest_Operation operation() const;
  void set_operation(::trojan::api::SetUsersRequest_Operation value);
  private:
  ::trojan::api::SetUsersRequest_Operation _internal_operation() const;
  void _internal_set_operation(::trojan::api::SetUsersRequest_Operation value);
  public:

  // int32 ip_limit = 4;
  void clear_ip_limit();
  ::PROTOBUF_NAMESPACE_ID::int32 ip_limit() const;
  void set_ip_limit(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ip_limit() const;
  void _internal_set_ip_limit(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:trojan.api.SetUsersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::trojan::api::User* user_;
  ::trojan::api::Speed* speed_limit_;
  int operation_;
  ::PROTOBUF_NAMESPACE_ID::int32 ip_limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trojangoapi_2eproto;
};
// -------------------------------------------------------------------

class SetUsersResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trojan.api.SetUsersResponse) */ {
 public:
  inline SetUsersResponse() : SetUsersResponse(nullptr) {};
  virtual ~SetUsersResponse();

  SetUsersResponse(const SetUsersResponse& from);
  SetUsersResponse(SetUsersResponse&& from) noexcept
    : SetUsersResponse() {
    *this = ::std::move(from);
  }

  inline SetUsersResponse& operator=(const SetUsersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetUsersResponse& operator=(SetUsersResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetUsersResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetUsersResponse* internal_default_instance() {
    return reinterpret_cast<const SetUsersResponse*>(
               &_SetUsersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SetUsersResponse& a, SetUsersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetUsersResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetUsersResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetUsersResponse* New() const final {
    return CreateMaybeMessage<SetUsersResponse>(nullptr);
  }

  SetUsersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetUsersResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetUsersResponse& from);
  void MergeFrom(const SetUsersResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetUsersResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trojan.api.SetUsersResponse";
  }
  protected:
  explicit SetUsersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trojangoapi_2eproto);
    return ::descriptor_table_trojangoapi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string info = 2;
  void clear_info();
  const std::string& info() const;
  void set_info(const std::string& value);
  void set_info(std::string&& value);
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  std::string* mutable_info();
  std::string* release_info();
  void set_allocated_info(std::string* info);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_info();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_info(
      std::string* info);
  private:
  const std::string& _internal_info() const;
  void _internal_set_info(const std::string& value);
  std::string* _internal_mutable_info();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:trojan.api.SetUsersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trojangoapi_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Traffic

// uint64 upload_traffic = 1;
inline void Traffic::clear_upload_traffic() {
  upload_traffic_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Traffic::_internal_upload_traffic() const {
  return upload_traffic_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Traffic::upload_traffic() const {
  // @@protoc_insertion_point(field_get:trojan.api.Traffic.upload_traffic)
  return _internal_upload_traffic();
}
inline void Traffic::_internal_set_upload_traffic(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  upload_traffic_ = value;
}
inline void Traffic::set_upload_traffic(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_upload_traffic(value);
  // @@protoc_insertion_point(field_set:trojan.api.Traffic.upload_traffic)
}

// uint64 download_traffic = 2;
inline void Traffic::clear_download_traffic() {
  download_traffic_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Traffic::_internal_download_traffic() const {
  return download_traffic_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Traffic::download_traffic() const {
  // @@protoc_insertion_point(field_get:trojan.api.Traffic.download_traffic)
  return _internal_download_traffic();
}
inline void Traffic::_internal_set_download_traffic(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  download_traffic_ = value;
}
inline void Traffic::set_download_traffic(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_download_traffic(value);
  // @@protoc_insertion_point(field_set:trojan.api.Traffic.download_traffic)
}

// -------------------------------------------------------------------

// Speed

// uint64 upload_speed = 1;
inline void Speed::clear_upload_speed() {
  upload_speed_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Speed::_internal_upload_speed() const {
  return upload_speed_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Speed::upload_speed() const {
  // @@protoc_insertion_point(field_get:trojan.api.Speed.upload_speed)
  return _internal_upload_speed();
}
inline void Speed::_internal_set_upload_speed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  upload_speed_ = value;
}
inline void Speed::set_upload_speed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_upload_speed(value);
  // @@protoc_insertion_point(field_set:trojan.api.Speed.upload_speed)
}

// uint64 download_speed = 2;
inline void Speed::clear_download_speed() {
  download_speed_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Speed::_internal_download_speed() const {
  return download_speed_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Speed::download_speed() const {
  // @@protoc_insertion_point(field_get:trojan.api.Speed.download_speed)
  return _internal_download_speed();
}
inline void Speed::_internal_set_download_speed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  download_speed_ = value;
}
inline void Speed::set_download_speed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_download_speed(value);
  // @@protoc_insertion_point(field_set:trojan.api.Speed.download_speed)
}

// -------------------------------------------------------------------

// User

// string password = 1;
inline void User::clear_password() {
  password_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& User::password() const {
  // @@protoc_insertion_point(field_get:trojan.api.User.password)
  return _internal_password();
}
inline void User::set_password(const std::string& value) {
  _internal_set_password(value);
  // @@protoc_insertion_point(field_set:trojan.api.User.password)
}
inline std::string* User::mutable_password() {
  // @@protoc_insertion_point(field_mutable:trojan.api.User.password)
  return _internal_mutable_password();
}
inline const std::string& User::_internal_password() const {
  return password_.Get();
}
inline void User::_internal_set_password(const std::string& value) {
  
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void User::set_password(std::string&& value) {
  
  password_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:trojan.api.User.password)
}
inline void User::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:trojan.api.User.password)
}
inline void User::set_password(const char* value,
    size_t size) {
  
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:trojan.api.User.password)
}
inline std::string* User::_internal_mutable_password() {
  
  return password_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* User::release_password() {
  // @@protoc_insertion_point(field_release:trojan.api.User.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void User::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:trojan.api.User.password)
}
inline std::string* User::unsafe_arena_release_password() {
  // @@protoc_insertion_point(field_unsafe_arena_release:trojan.api.User.password)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return password_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void User::unsafe_arena_set_allocated_password(
    std::string* password) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (password != nullptr) {
    
  } else {
    
  }
  password_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      password, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trojan.api.User.password)
}

// string hash = 2;
inline void User::clear_hash() {
  hash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& User::hash() const {
  // @@protoc_insertion_point(field_get:trojan.api.User.hash)
  return _internal_hash();
}
inline void User::set_hash(const std::string& value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:trojan.api.User.hash)
}
inline std::string* User::mutable_hash() {
  // @@protoc_insertion_point(field_mutable:trojan.api.User.hash)
  return _internal_mutable_hash();
}
inline const std::string& User::_internal_hash() const {
  return hash_.Get();
}
inline void User::_internal_set_hash(const std::string& value) {
  
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void User::set_hash(std::string&& value) {
  
  hash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:trojan.api.User.hash)
}
inline void User::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:trojan.api.User.hash)
}
inline void User::set_hash(const char* value,
    size_t size) {
  
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:trojan.api.User.hash)
}
inline std::string* User::_internal_mutable_hash() {
  
  return hash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* User::release_hash() {
  // @@protoc_insertion_point(field_release:trojan.api.User.hash)
  return hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void User::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:trojan.api.User.hash)
}
inline std::string* User::unsafe_arena_release_hash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:trojan.api.User.hash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return hash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void User::unsafe_arena_set_allocated_hash(
    std::string* hash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      hash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trojan.api.User.hash)
}

// -------------------------------------------------------------------

// UserStatus

// .trojan.api.User user = 1;
inline bool UserStatus::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool UserStatus::has_user() const {
  return _internal_has_user();
}
inline void UserStatus::clear_user() {
  if (GetArena() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::trojan::api::User& UserStatus::_internal_user() const {
  const ::trojan::api::User* p = user_;
  return p != nullptr ? *p : *reinterpret_cast<const ::trojan::api::User*>(
      &::trojan::api::_User_default_instance_);
}
inline const ::trojan::api::User& UserStatus::user() const {
  // @@protoc_insertion_point(field_get:trojan.api.UserStatus.user)
  return _internal_user();
}
inline void UserStatus::unsafe_arena_set_allocated_user(
    ::trojan::api::User* user) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trojan.api.UserStatus.user)
}
inline ::trojan::api::User* UserStatus::release_user() {
  auto temp = unsafe_arena_release_user();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::trojan::api::User* UserStatus::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:trojan.api.UserStatus.user)
  
  ::trojan::api::User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::trojan::api::User* UserStatus::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::trojan::api::User>(GetArena());
    user_ = p;
  }
  return user_;
}
inline ::trojan::api::User* UserStatus::mutable_user() {
  // @@protoc_insertion_point(field_mutable:trojan.api.UserStatus.user)
  return _internal_mutable_user();
}
inline void UserStatus::set_allocated_user(::trojan::api::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:trojan.api.UserStatus.user)
}

// .trojan.api.Traffic traffic_total = 2;
inline bool UserStatus::_internal_has_traffic_total() const {
  return this != internal_default_instance() && traffic_total_ != nullptr;
}
inline bool UserStatus::has_traffic_total() const {
  return _internal_has_traffic_total();
}
inline void UserStatus::clear_traffic_total() {
  if (GetArena() == nullptr && traffic_total_ != nullptr) {
    delete traffic_total_;
  }
  traffic_total_ = nullptr;
}
inline const ::trojan::api::Traffic& UserStatus::_internal_traffic_total() const {
  const ::trojan::api::Traffic* p = traffic_total_;
  return p != nullptr ? *p : *reinterpret_cast<const ::trojan::api::Traffic*>(
      &::trojan::api::_Traffic_default_instance_);
}
inline const ::trojan::api::Traffic& UserStatus::traffic_total() const {
  // @@protoc_insertion_point(field_get:trojan.api.UserStatus.traffic_total)
  return _internal_traffic_total();
}
inline void UserStatus::unsafe_arena_set_allocated_traffic_total(
    ::trojan::api::Traffic* traffic_total) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(traffic_total_);
  }
  traffic_total_ = traffic_total;
  if (traffic_total) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trojan.api.UserStatus.traffic_total)
}
inline ::trojan::api::Traffic* UserStatus::release_traffic_total() {
  auto temp = unsafe_arena_release_traffic_total();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::trojan::api::Traffic* UserStatus::unsafe_arena_release_traffic_total() {
  // @@protoc_insertion_point(field_release:trojan.api.UserStatus.traffic_total)
  
  ::trojan::api::Traffic* temp = traffic_total_;
  traffic_total_ = nullptr;
  return temp;
}
inline ::trojan::api::Traffic* UserStatus::_internal_mutable_traffic_total() {
  
  if (traffic_total_ == nullptr) {
    auto* p = CreateMaybeMessage<::trojan::api::Traffic>(GetArena());
    traffic_total_ = p;
  }
  return traffic_total_;
}
inline ::trojan::api::Traffic* UserStatus::mutable_traffic_total() {
  // @@protoc_insertion_point(field_mutable:trojan.api.UserStatus.traffic_total)
  return _internal_mutable_traffic_total();
}
inline void UserStatus::set_allocated_traffic_total(::trojan::api::Traffic* traffic_total) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete traffic_total_;
  }
  if (traffic_total) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(traffic_total);
    if (message_arena != submessage_arena) {
      traffic_total = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, traffic_total, submessage_arena);
    }
    
  } else {
    
  }
  traffic_total_ = traffic_total;
  // @@protoc_insertion_point(field_set_allocated:trojan.api.UserStatus.traffic_total)
}

// .trojan.api.Speed speed_current = 3;
inline bool UserStatus::_internal_has_speed_current() const {
  return this != internal_default_instance() && speed_current_ != nullptr;
}
inline bool UserStatus::has_speed_current() const {
  return _internal_has_speed_current();
}
inline void UserStatus::clear_speed_current() {
  if (GetArena() == nullptr && speed_current_ != nullptr) {
    delete speed_current_;
  }
  speed_current_ = nullptr;
}
inline const ::trojan::api::Speed& UserStatus::_internal_speed_current() const {
  const ::trojan::api::Speed* p = speed_current_;
  return p != nullptr ? *p : *reinterpret_cast<const ::trojan::api::Speed*>(
      &::trojan::api::_Speed_default_instance_);
}
inline const ::trojan::api::Speed& UserStatus::speed_current() const {
  // @@protoc_insertion_point(field_get:trojan.api.UserStatus.speed_current)
  return _internal_speed_current();
}
inline void UserStatus::unsafe_arena_set_allocated_speed_current(
    ::trojan::api::Speed* speed_current) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(speed_current_);
  }
  speed_current_ = speed_current;
  if (speed_current) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trojan.api.UserStatus.speed_current)
}
inline ::trojan::api::Speed* UserStatus::release_speed_current() {
  auto temp = unsafe_arena_release_speed_current();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::trojan::api::Speed* UserStatus::unsafe_arena_release_speed_current() {
  // @@protoc_insertion_point(field_release:trojan.api.UserStatus.speed_current)
  
  ::trojan::api::Speed* temp = speed_current_;
  speed_current_ = nullptr;
  return temp;
}
inline ::trojan::api::Speed* UserStatus::_internal_mutable_speed_current() {
  
  if (speed_current_ == nullptr) {
    auto* p = CreateMaybeMessage<::trojan::api::Speed>(GetArena());
    speed_current_ = p;
  }
  return speed_current_;
}
inline ::trojan::api::Speed* UserStatus::mutable_speed_current() {
  // @@protoc_insertion_point(field_mutable:trojan.api.UserStatus.speed_current)
  return _internal_mutable_speed_current();
}
inline void UserStatus::set_allocated_speed_current(::trojan::api::Speed* speed_current) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete speed_current_;
  }
  if (speed_current) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(speed_current);
    if (message_arena != submessage_arena) {
      speed_current = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, speed_current, submessage_arena);
    }
    
  } else {
    
  }
  speed_current_ = speed_current;
  // @@protoc_insertion_point(field_set_allocated:trojan.api.UserStatus.speed_current)
}

// .trojan.api.Speed speed_limit = 4;
inline bool UserStatus::_internal_has_speed_limit() const {
  return this != internal_default_instance() && speed_limit_ != nullptr;
}
inline bool UserStatus::has_speed_limit() const {
  return _internal_has_speed_limit();
}
inline void UserStatus::clear_speed_limit() {
  if (GetArena() == nullptr && speed_limit_ != nullptr) {
    delete speed_limit_;
  }
  speed_limit_ = nullptr;
}
inline const ::trojan::api::Speed& UserStatus::_internal_speed_limit() const {
  const ::trojan::api::Speed* p = speed_limit_;
  return p != nullptr ? *p : *reinterpret_cast<const ::trojan::api::Speed*>(
      &::trojan::api::_Speed_default_instance_);
}
inline const ::trojan::api::Speed& UserStatus::speed_limit() const {
  // @@protoc_insertion_point(field_get:trojan.api.UserStatus.speed_limit)
  return _internal_speed_limit();
}
inline void UserStatus::unsafe_arena_set_allocated_speed_limit(
    ::trojan::api::Speed* speed_limit) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(speed_limit_);
  }
  speed_limit_ = speed_limit;
  if (speed_limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trojan.api.UserStatus.speed_limit)
}
inline ::trojan::api::Speed* UserStatus::release_speed_limit() {
  auto temp = unsafe_arena_release_speed_limit();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::trojan::api::Speed* UserStatus::unsafe_arena_release_speed_limit() {
  // @@protoc_insertion_point(field_release:trojan.api.UserStatus.speed_limit)
  
  ::trojan::api::Speed* temp = speed_limit_;
  speed_limit_ = nullptr;
  return temp;
}
inline ::trojan::api::Speed* UserStatus::_internal_mutable_speed_limit() {
  
  if (speed_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::trojan::api::Speed>(GetArena());
    speed_limit_ = p;
  }
  return speed_limit_;
}
inline ::trojan::api::Speed* UserStatus::mutable_speed_limit() {
  // @@protoc_insertion_point(field_mutable:trojan.api.UserStatus.speed_limit)
  return _internal_mutable_speed_limit();
}
inline void UserStatus::set_allocated_speed_limit(::trojan::api::Speed* speed_limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete speed_limit_;
  }
  if (speed_limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(speed_limit);
    if (message_arena != submessage_arena) {
      speed_limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, speed_limit, submessage_arena);
    }
    
  } else {
    
  }
  speed_limit_ = speed_limit;
  // @@protoc_insertion_point(field_set_allocated:trojan.api.UserStatus.speed_limit)
}

// int32 ip_current = 5;
inline void UserStatus::clear_ip_current() {
  ip_current_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UserStatus::_internal_ip_current() const {
  return ip_current_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UserStatus::ip_current() const {
  // @@protoc_insertion_point(field_get:trojan.api.UserStatus.ip_current)
  return _internal_ip_current();
}
inline void UserStatus::_internal_set_ip_current(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  ip_current_ = value;
}
inline void UserStatus::set_ip_current(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ip_current(value);
  // @@protoc_insertion_point(field_set:trojan.api.UserStatus.ip_current)
}

// int32 ip_limit = 6;
inline void UserStatus::clear_ip_limit() {
  ip_limit_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UserStatus::_internal_ip_limit() const {
  return ip_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UserStatus::ip_limit() const {
  // @@protoc_insertion_point(field_get:trojan.api.UserStatus.ip_limit)
  return _internal_ip_limit();
}
inline void UserStatus::_internal_set_ip_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  ip_limit_ = value;
}
inline void UserStatus::set_ip_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ip_limit(value);
  // @@protoc_insertion_point(field_set:trojan.api.UserStatus.ip_limit)
}

// -------------------------------------------------------------------

// GetTrafficRequest

// .trojan.api.User user = 1;
inline bool GetTrafficRequest::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool GetTrafficRequest::has_user() const {
  return _internal_has_user();
}
inline void GetTrafficRequest::clear_user() {
  if (GetArena() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::trojan::api::User& GetTrafficRequest::_internal_user() const {
  const ::trojan::api::User* p = user_;
  return p != nullptr ? *p : *reinterpret_cast<const ::trojan::api::User*>(
      &::trojan::api::_User_default_instance_);
}
inline const ::trojan::api::User& GetTrafficRequest::user() const {
  // @@protoc_insertion_point(field_get:trojan.api.GetTrafficRequest.user)
  return _internal_user();
}
inline void GetTrafficRequest::unsafe_arena_set_allocated_user(
    ::trojan::api::User* user) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trojan.api.GetTrafficRequest.user)
}
inline ::trojan::api::User* GetTrafficRequest::release_user() {
  auto temp = unsafe_arena_release_user();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::trojan::api::User* GetTrafficRequest::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:trojan.api.GetTrafficRequest.user)
  
  ::trojan::api::User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::trojan::api::User* GetTrafficRequest::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::trojan::api::User>(GetArena());
    user_ = p;
  }
  return user_;
}
inline ::trojan::api::User* GetTrafficRequest::mutable_user() {
  // @@protoc_insertion_point(field_mutable:trojan.api.GetTrafficRequest.user)
  return _internal_mutable_user();
}
inline void GetTrafficRequest::set_allocated_user(::trojan::api::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:trojan.api.GetTrafficRequest.user)
}

// -------------------------------------------------------------------

// GetTrafficResponse

// bool success = 1;
inline void GetTrafficResponse::clear_success() {
  success_ = false;
}
inline bool GetTrafficResponse::_internal_success() const {
  return success_;
}
inline bool GetTrafficResponse::success() const {
  // @@protoc_insertion_point(field_get:trojan.api.GetTrafficResponse.success)
  return _internal_success();
}
inline void GetTrafficResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void GetTrafficResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:trojan.api.GetTrafficResponse.success)
}

// string info = 2;
inline void GetTrafficResponse::clear_info() {
  info_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetTrafficResponse::info() const {
  // @@protoc_insertion_point(field_get:trojan.api.GetTrafficResponse.info)
  return _internal_info();
}
inline void GetTrafficResponse::set_info(const std::string& value) {
  _internal_set_info(value);
  // @@protoc_insertion_point(field_set:trojan.api.GetTrafficResponse.info)
}
inline std::string* GetTrafficResponse::mutable_info() {
  // @@protoc_insertion_point(field_mutable:trojan.api.GetTrafficResponse.info)
  return _internal_mutable_info();
}
inline const std::string& GetTrafficResponse::_internal_info() const {
  return info_.Get();
}
inline void GetTrafficResponse::_internal_set_info(const std::string& value) {
  
  info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetTrafficResponse::set_info(std::string&& value) {
  
  info_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:trojan.api.GetTrafficResponse.info)
}
inline void GetTrafficResponse::set_info(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:trojan.api.GetTrafficResponse.info)
}
inline void GetTrafficResponse::set_info(const char* value,
    size_t size) {
  
  info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:trojan.api.GetTrafficResponse.info)
}
inline std::string* GetTrafficResponse::_internal_mutable_info() {
  
  return info_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetTrafficResponse::release_info() {
  // @@protoc_insertion_point(field_release:trojan.api.GetTrafficResponse.info)
  return info_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetTrafficResponse::set_allocated_info(std::string* info) {
  if (info != nullptr) {
    
  } else {
    
  }
  info_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), info,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:trojan.api.GetTrafficResponse.info)
}
inline std::string* GetTrafficResponse::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:trojan.api.GetTrafficResponse.info)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return info_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetTrafficResponse::unsafe_arena_set_allocated_info(
    std::string* info) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (info != nullptr) {
    
  } else {
    
  }
  info_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      info, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trojan.api.GetTrafficResponse.info)
}

// .trojan.api.Traffic traffic_total = 3;
inline bool GetTrafficResponse::_internal_has_traffic_total() const {
  return this != internal_default_instance() && traffic_total_ != nullptr;
}
inline bool GetTrafficResponse::has_traffic_total() const {
  return _internal_has_traffic_total();
}
inline void GetTrafficResponse::clear_traffic_total() {
  if (GetArena() == nullptr && traffic_total_ != nullptr) {
    delete traffic_total_;
  }
  traffic_total_ = nullptr;
}
inline const ::trojan::api::Traffic& GetTrafficResponse::_internal_traffic_total() const {
  const ::trojan::api::Traffic* p = traffic_total_;
  return p != nullptr ? *p : *reinterpret_cast<const ::trojan::api::Traffic*>(
      &::trojan::api::_Traffic_default_instance_);
}
inline const ::trojan::api::Traffic& GetTrafficResponse::traffic_total() const {
  // @@protoc_insertion_point(field_get:trojan.api.GetTrafficResponse.traffic_total)
  return _internal_traffic_total();
}
inline void GetTrafficResponse::unsafe_arena_set_allocated_traffic_total(
    ::trojan::api::Traffic* traffic_total) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(traffic_total_);
  }
  traffic_total_ = traffic_total;
  if (traffic_total) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trojan.api.GetTrafficResponse.traffic_total)
}
inline ::trojan::api::Traffic* GetTrafficResponse::release_traffic_total() {
  auto temp = unsafe_arena_release_traffic_total();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::trojan::api::Traffic* GetTrafficResponse::unsafe_arena_release_traffic_total() {
  // @@protoc_insertion_point(field_release:trojan.api.GetTrafficResponse.traffic_total)
  
  ::trojan::api::Traffic* temp = traffic_total_;
  traffic_total_ = nullptr;
  return temp;
}
inline ::trojan::api::Traffic* GetTrafficResponse::_internal_mutable_traffic_total() {
  
  if (traffic_total_ == nullptr) {
    auto* p = CreateMaybeMessage<::trojan::api::Traffic>(GetArena());
    traffic_total_ = p;
  }
  return traffic_total_;
}
inline ::trojan::api::Traffic* GetTrafficResponse::mutable_traffic_total() {
  // @@protoc_insertion_point(field_mutable:trojan.api.GetTrafficResponse.traffic_total)
  return _internal_mutable_traffic_total();
}
inline void GetTrafficResponse::set_allocated_traffic_total(::trojan::api::Traffic* traffic_total) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete traffic_total_;
  }
  if (traffic_total) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(traffic_total);
    if (message_arena != submessage_arena) {
      traffic_total = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, traffic_total, submessage_arena);
    }
    
  } else {
    
  }
  traffic_total_ = traffic_total;
  // @@protoc_insertion_point(field_set_allocated:trojan.api.GetTrafficResponse.traffic_total)
}

// .trojan.api.Speed speed_current = 4;
inline bool GetTrafficResponse::_internal_has_speed_current() const {
  return this != internal_default_instance() && speed_current_ != nullptr;
}
inline bool GetTrafficResponse::has_speed_current() const {
  return _internal_has_speed_current();
}
inline void GetTrafficResponse::clear_speed_current() {
  if (GetArena() == nullptr && speed_current_ != nullptr) {
    delete speed_current_;
  }
  speed_current_ = nullptr;
}
inline const ::trojan::api::Speed& GetTrafficResponse::_internal_speed_current() const {
  const ::trojan::api::Speed* p = speed_current_;
  return p != nullptr ? *p : *reinterpret_cast<const ::trojan::api::Speed*>(
      &::trojan::api::_Speed_default_instance_);
}
inline const ::trojan::api::Speed& GetTrafficResponse::speed_current() const {
  // @@protoc_insertion_point(field_get:trojan.api.GetTrafficResponse.speed_current)
  return _internal_speed_current();
}
inline void GetTrafficResponse::unsafe_arena_set_allocated_speed_current(
    ::trojan::api::Speed* speed_current) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(speed_current_);
  }
  speed_current_ = speed_current;
  if (speed_current) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trojan.api.GetTrafficResponse.speed_current)
}
inline ::trojan::api::Speed* GetTrafficResponse::release_speed_current() {
  auto temp = unsafe_arena_release_speed_current();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::trojan::api::Speed* GetTrafficResponse::unsafe_arena_release_speed_current() {
  // @@protoc_insertion_point(field_release:trojan.api.GetTrafficResponse.speed_current)
  
  ::trojan::api::Speed* temp = speed_current_;
  speed_current_ = nullptr;
  return temp;
}
inline ::trojan::api::Speed* GetTrafficResponse::_internal_mutable_speed_current() {
  
  if (speed_current_ == nullptr) {
    auto* p = CreateMaybeMessage<::trojan::api::Speed>(GetArena());
    speed_current_ = p;
  }
  return speed_current_;
}
inline ::trojan::api::Speed* GetTrafficResponse::mutable_speed_current() {
  // @@protoc_insertion_point(field_mutable:trojan.api.GetTrafficResponse.speed_current)
  return _internal_mutable_speed_current();
}
inline void GetTrafficResponse::set_allocated_speed_current(::trojan::api::Speed* speed_current) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete speed_current_;
  }
  if (speed_current) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(speed_current);
    if (message_arena != submessage_arena) {
      speed_current = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, speed_current, submessage_arena);
    }
    
  } else {
    
  }
  speed_current_ = speed_current;
  // @@protoc_insertion_point(field_set_allocated:trojan.api.GetTrafficResponse.speed_current)
}

// -------------------------------------------------------------------

// ListUsersRequest

// -------------------------------------------------------------------

// ListUsersResponse

// .trojan.api.User user = 1;
inline bool ListUsersResponse::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool ListUsersResponse::has_user() const {
  return _internal_has_user();
}
inline void ListUsersResponse::clear_user() {
  if (GetArena() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::trojan::api::User& ListUsersResponse::_internal_user() const {
  const ::trojan::api::User* p = user_;
  return p != nullptr ? *p : *reinterpret_cast<const ::trojan::api::User*>(
      &::trojan::api::_User_default_instance_);
}
inline const ::trojan::api::User& ListUsersResponse::user() const {
  // @@protoc_insertion_point(field_get:trojan.api.ListUsersResponse.user)
  return _internal_user();
}
inline void ListUsersResponse::unsafe_arena_set_allocated_user(
    ::trojan::api::User* user) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trojan.api.ListUsersResponse.user)
}
inline ::trojan::api::User* ListUsersResponse::release_user() {
  auto temp = unsafe_arena_release_user();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::trojan::api::User* ListUsersResponse::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:trojan.api.ListUsersResponse.user)
  
  ::trojan::api::User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::trojan::api::User* ListUsersResponse::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::trojan::api::User>(GetArena());
    user_ = p;
  }
  return user_;
}
inline ::trojan::api::User* ListUsersResponse::mutable_user() {
  // @@protoc_insertion_point(field_mutable:trojan.api.ListUsersResponse.user)
  return _internal_mutable_user();
}
inline void ListUsersResponse::set_allocated_user(::trojan::api::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:trojan.api.ListUsersResponse.user)
}

// .trojan.api.UserStatus status = 2;
inline bool ListUsersResponse::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool ListUsersResponse::has_status() const {
  return _internal_has_status();
}
inline void ListUsersResponse::clear_status() {
  if (GetArena() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::trojan::api::UserStatus& ListUsersResponse::_internal_status() const {
  const ::trojan::api::UserStatus* p = status_;
  return p != nullptr ? *p : *reinterpret_cast<const ::trojan::api::UserStatus*>(
      &::trojan::api::_UserStatus_default_instance_);
}
inline const ::trojan::api::UserStatus& ListUsersResponse::status() const {
  // @@protoc_insertion_point(field_get:trojan.api.ListUsersResponse.status)
  return _internal_status();
}
inline void ListUsersResponse::unsafe_arena_set_allocated_status(
    ::trojan::api::UserStatus* status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trojan.api.ListUsersResponse.status)
}
inline ::trojan::api::UserStatus* ListUsersResponse::release_status() {
  auto temp = unsafe_arena_release_status();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::trojan::api::UserStatus* ListUsersResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:trojan.api.ListUsersResponse.status)
  
  ::trojan::api::UserStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::trojan::api::UserStatus* ListUsersResponse::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::trojan::api::UserStatus>(GetArena());
    status_ = p;
  }
  return status_;
}
inline ::trojan::api::UserStatus* ListUsersResponse::mutable_status() {
  // @@protoc_insertion_point(field_mutable:trojan.api.ListUsersResponse.status)
  return _internal_mutable_status();
}
inline void ListUsersResponse::set_allocated_status(::trojan::api::UserStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:trojan.api.ListUsersResponse.status)
}

// -------------------------------------------------------------------

// GetUsersRequest

// .trojan.api.User user = 1;
inline bool GetUsersRequest::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool GetUsersRequest::has_user() const {
  return _internal_has_user();
}
inline void GetUsersRequest::clear_user() {
  if (GetArena() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::trojan::api::User& GetUsersRequest::_internal_user() const {
  const ::trojan::api::User* p = user_;
  return p != nullptr ? *p : *reinterpret_cast<const ::trojan::api::User*>(
      &::trojan::api::_User_default_instance_);
}
inline const ::trojan::api::User& GetUsersRequest::user() const {
  // @@protoc_insertion_point(field_get:trojan.api.GetUsersRequest.user)
  return _internal_user();
}
inline void GetUsersRequest::unsafe_arena_set_allocated_user(
    ::trojan::api::User* user) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trojan.api.GetUsersRequest.user)
}
inline ::trojan::api::User* GetUsersRequest::release_user() {
  auto temp = unsafe_arena_release_user();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::trojan::api::User* GetUsersRequest::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:trojan.api.GetUsersRequest.user)
  
  ::trojan::api::User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::trojan::api::User* GetUsersRequest::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::trojan::api::User>(GetArena());
    user_ = p;
  }
  return user_;
}
inline ::trojan::api::User* GetUsersRequest::mutable_user() {
  // @@protoc_insertion_point(field_mutable:trojan.api.GetUsersRequest.user)
  return _internal_mutable_user();
}
inline void GetUsersRequest::set_allocated_user(::trojan::api::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:trojan.api.GetUsersRequest.user)
}

// -------------------------------------------------------------------

// GetUsersResponse

// bool success = 1;
inline void GetUsersResponse::clear_success() {
  success_ = false;
}
inline bool GetUsersResponse::_internal_success() const {
  return success_;
}
inline bool GetUsersResponse::success() const {
  // @@protoc_insertion_point(field_get:trojan.api.GetUsersResponse.success)
  return _internal_success();
}
inline void GetUsersResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void GetUsersResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:trojan.api.GetUsersResponse.success)
}

// string info = 2;
inline void GetUsersResponse::clear_info() {
  info_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetUsersResponse::info() const {
  // @@protoc_insertion_point(field_get:trojan.api.GetUsersResponse.info)
  return _internal_info();
}
inline void GetUsersResponse::set_info(const std::string& value) {
  _internal_set_info(value);
  // @@protoc_insertion_point(field_set:trojan.api.GetUsersResponse.info)
}
inline std::string* GetUsersResponse::mutable_info() {
  // @@protoc_insertion_point(field_mutable:trojan.api.GetUsersResponse.info)
  return _internal_mutable_info();
}
inline const std::string& GetUsersResponse::_internal_info() const {
  return info_.Get();
}
inline void GetUsersResponse::_internal_set_info(const std::string& value) {
  
  info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetUsersResponse::set_info(std::string&& value) {
  
  info_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:trojan.api.GetUsersResponse.info)
}
inline void GetUsersResponse::set_info(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:trojan.api.GetUsersResponse.info)
}
inline void GetUsersResponse::set_info(const char* value,
    size_t size) {
  
  info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:trojan.api.GetUsersResponse.info)
}
inline std::string* GetUsersResponse::_internal_mutable_info() {
  
  return info_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetUsersResponse::release_info() {
  // @@protoc_insertion_point(field_release:trojan.api.GetUsersResponse.info)
  return info_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetUsersResponse::set_allocated_info(std::string* info) {
  if (info != nullptr) {
    
  } else {
    
  }
  info_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), info,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:trojan.api.GetUsersResponse.info)
}
inline std::string* GetUsersResponse::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:trojan.api.GetUsersResponse.info)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return info_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetUsersResponse::unsafe_arena_set_allocated_info(
    std::string* info) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (info != nullptr) {
    
  } else {
    
  }
  info_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      info, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trojan.api.GetUsersResponse.info)
}

// .trojan.api.User user = 3;
inline bool GetUsersResponse::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool GetUsersResponse::has_user() const {
  return _internal_has_user();
}
inline void GetUsersResponse::clear_user() {
  if (GetArena() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::trojan::api::User& GetUsersResponse::_internal_user() const {
  const ::trojan::api::User* p = user_;
  return p != nullptr ? *p : *reinterpret_cast<const ::trojan::api::User*>(
      &::trojan::api::_User_default_instance_);
}
inline const ::trojan::api::User& GetUsersResponse::user() const {
  // @@protoc_insertion_point(field_get:trojan.api.GetUsersResponse.user)
  return _internal_user();
}
inline void GetUsersResponse::unsafe_arena_set_allocated_user(
    ::trojan::api::User* user) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trojan.api.GetUsersResponse.user)
}
inline ::trojan::api::User* GetUsersResponse::release_user() {
  auto temp = unsafe_arena_release_user();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::trojan::api::User* GetUsersResponse::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:trojan.api.GetUsersResponse.user)
  
  ::trojan::api::User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::trojan::api::User* GetUsersResponse::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::trojan::api::User>(GetArena());
    user_ = p;
  }
  return user_;
}
inline ::trojan::api::User* GetUsersResponse::mutable_user() {
  // @@protoc_insertion_point(field_mutable:trojan.api.GetUsersResponse.user)
  return _internal_mutable_user();
}
inline void GetUsersResponse::set_allocated_user(::trojan::api::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:trojan.api.GetUsersResponse.user)
}

// .trojan.api.UserStatus status = 4;
inline bool GetUsersResponse::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool GetUsersResponse::has_status() const {
  return _internal_has_status();
}
inline void GetUsersResponse::clear_status() {
  if (GetArena() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::trojan::api::UserStatus& GetUsersResponse::_internal_status() const {
  const ::trojan::api::UserStatus* p = status_;
  return p != nullptr ? *p : *reinterpret_cast<const ::trojan::api::UserStatus*>(
      &::trojan::api::_UserStatus_default_instance_);
}
inline const ::trojan::api::UserStatus& GetUsersResponse::status() const {
  // @@protoc_insertion_point(field_get:trojan.api.GetUsersResponse.status)
  return _internal_status();
}
inline void GetUsersResponse::unsafe_arena_set_allocated_status(
    ::trojan::api::UserStatus* status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trojan.api.GetUsersResponse.status)
}
inline ::trojan::api::UserStatus* GetUsersResponse::release_status() {
  auto temp = unsafe_arena_release_status();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::trojan::api::UserStatus* GetUsersResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:trojan.api.GetUsersResponse.status)
  
  ::trojan::api::UserStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::trojan::api::UserStatus* GetUsersResponse::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::trojan::api::UserStatus>(GetArena());
    status_ = p;
  }
  return status_;
}
inline ::trojan::api::UserStatus* GetUsersResponse::mutable_status() {
  // @@protoc_insertion_point(field_mutable:trojan.api.GetUsersResponse.status)
  return _internal_mutable_status();
}
inline void GetUsersResponse::set_allocated_status(::trojan::api::UserStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:trojan.api.GetUsersResponse.status)
}

// -------------------------------------------------------------------

// SetUsersRequest

// .trojan.api.User user = 1;
inline bool SetUsersRequest::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool SetUsersRequest::has_user() const {
  return _internal_has_user();
}
inline void SetUsersRequest::clear_user() {
  if (GetArena() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::trojan::api::User& SetUsersRequest::_internal_user() const {
  const ::trojan::api::User* p = user_;
  return p != nullptr ? *p : *reinterpret_cast<const ::trojan::api::User*>(
      &::trojan::api::_User_default_instance_);
}
inline const ::trojan::api::User& SetUsersRequest::user() const {
  // @@protoc_insertion_point(field_get:trojan.api.SetUsersRequest.user)
  return _internal_user();
}
inline void SetUsersRequest::unsafe_arena_set_allocated_user(
    ::trojan::api::User* user) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trojan.api.SetUsersRequest.user)
}
inline ::trojan::api::User* SetUsersRequest::release_user() {
  auto temp = unsafe_arena_release_user();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::trojan::api::User* SetUsersRequest::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:trojan.api.SetUsersRequest.user)
  
  ::trojan::api::User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::trojan::api::User* SetUsersRequest::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::trojan::api::User>(GetArena());
    user_ = p;
  }
  return user_;
}
inline ::trojan::api::User* SetUsersRequest::mutable_user() {
  // @@protoc_insertion_point(field_mutable:trojan.api.SetUsersRequest.user)
  return _internal_mutable_user();
}
inline void SetUsersRequest::set_allocated_user(::trojan::api::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:trojan.api.SetUsersRequest.user)
}

// .trojan.api.SetUsersRequest.Operation operation = 2;
inline void SetUsersRequest::clear_operation() {
  operation_ = 0;
}
inline ::trojan::api::SetUsersRequest_Operation SetUsersRequest::_internal_operation() const {
  return static_cast< ::trojan::api::SetUsersRequest_Operation >(operation_);
}
inline ::trojan::api::SetUsersRequest_Operation SetUsersRequest::operation() const {
  // @@protoc_insertion_point(field_get:trojan.api.SetUsersRequest.operation)
  return _internal_operation();
}
inline void SetUsersRequest::_internal_set_operation(::trojan::api::SetUsersRequest_Operation value) {
  
  operation_ = value;
}
inline void SetUsersRequest::set_operation(::trojan::api::SetUsersRequest_Operation value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:trojan.api.SetUsersRequest.operation)
}

// .trojan.api.Speed speed_limit = 3;
inline bool SetUsersRequest::_internal_has_speed_limit() const {
  return this != internal_default_instance() && speed_limit_ != nullptr;
}
inline bool SetUsersRequest::has_speed_limit() const {
  return _internal_has_speed_limit();
}
inline void SetUsersRequest::clear_speed_limit() {
  if (GetArena() == nullptr && speed_limit_ != nullptr) {
    delete speed_limit_;
  }
  speed_limit_ = nullptr;
}
inline const ::trojan::api::Speed& SetUsersRequest::_internal_speed_limit() const {
  const ::trojan::api::Speed* p = speed_limit_;
  return p != nullptr ? *p : *reinterpret_cast<const ::trojan::api::Speed*>(
      &::trojan::api::_Speed_default_instance_);
}
inline const ::trojan::api::Speed& SetUsersRequest::speed_limit() const {
  // @@protoc_insertion_point(field_get:trojan.api.SetUsersRequest.speed_limit)
  return _internal_speed_limit();
}
inline void SetUsersRequest::unsafe_arena_set_allocated_speed_limit(
    ::trojan::api::Speed* speed_limit) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(speed_limit_);
  }
  speed_limit_ = speed_limit;
  if (speed_limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trojan.api.SetUsersRequest.speed_limit)
}
inline ::trojan::api::Speed* SetUsersRequest::release_speed_limit() {
  auto temp = unsafe_arena_release_speed_limit();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::trojan::api::Speed* SetUsersRequest::unsafe_arena_release_speed_limit() {
  // @@protoc_insertion_point(field_release:trojan.api.SetUsersRequest.speed_limit)
  
  ::trojan::api::Speed* temp = speed_limit_;
  speed_limit_ = nullptr;
  return temp;
}
inline ::trojan::api::Speed* SetUsersRequest::_internal_mutable_speed_limit() {
  
  if (speed_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::trojan::api::Speed>(GetArena());
    speed_limit_ = p;
  }
  return speed_limit_;
}
inline ::trojan::api::Speed* SetUsersRequest::mutable_speed_limit() {
  // @@protoc_insertion_point(field_mutable:trojan.api.SetUsersRequest.speed_limit)
  return _internal_mutable_speed_limit();
}
inline void SetUsersRequest::set_allocated_speed_limit(::trojan::api::Speed* speed_limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete speed_limit_;
  }
  if (speed_limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(speed_limit);
    if (message_arena != submessage_arena) {
      speed_limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, speed_limit, submessage_arena);
    }
    
  } else {
    
  }
  speed_limit_ = speed_limit;
  // @@protoc_insertion_point(field_set_allocated:trojan.api.SetUsersRequest.speed_limit)
}

// int32 ip_limit = 4;
inline void SetUsersRequest::clear_ip_limit() {
  ip_limit_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SetUsersRequest::_internal_ip_limit() const {
  return ip_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SetUsersRequest::ip_limit() const {
  // @@protoc_insertion_point(field_get:trojan.api.SetUsersRequest.ip_limit)
  return _internal_ip_limit();
}
inline void SetUsersRequest::_internal_set_ip_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  ip_limit_ = value;
}
inline void SetUsersRequest::set_ip_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ip_limit(value);
  // @@protoc_insertion_point(field_set:trojan.api.SetUsersRequest.ip_limit)
}

// -------------------------------------------------------------------

// SetUsersResponse

// bool success = 1;
inline void SetUsersResponse::clear_success() {
  success_ = false;
}
inline bool SetUsersResponse::_internal_success() const {
  return success_;
}
inline bool SetUsersResponse::success() const {
  // @@protoc_insertion_point(field_get:trojan.api.SetUsersResponse.success)
  return _internal_success();
}
inline void SetUsersResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void SetUsersResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:trojan.api.SetUsersResponse.success)
}

// string info = 2;
inline void SetUsersResponse::clear_info() {
  info_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SetUsersResponse::info() const {
  // @@protoc_insertion_point(field_get:trojan.api.SetUsersResponse.info)
  return _internal_info();
}
inline void SetUsersResponse::set_info(const std::string& value) {
  _internal_set_info(value);
  // @@protoc_insertion_point(field_set:trojan.api.SetUsersResponse.info)
}
inline std::string* SetUsersResponse::mutable_info() {
  // @@protoc_insertion_point(field_mutable:trojan.api.SetUsersResponse.info)
  return _internal_mutable_info();
}
inline const std::string& SetUsersResponse::_internal_info() const {
  return info_.Get();
}
inline void SetUsersResponse::_internal_set_info(const std::string& value) {
  
  info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetUsersResponse::set_info(std::string&& value) {
  
  info_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:trojan.api.SetUsersResponse.info)
}
inline void SetUsersResponse::set_info(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:trojan.api.SetUsersResponse.info)
}
inline void SetUsersResponse::set_info(const char* value,
    size_t size) {
  
  info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:trojan.api.SetUsersResponse.info)
}
inline std::string* SetUsersResponse::_internal_mutable_info() {
  
  return info_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetUsersResponse::release_info() {
  // @@protoc_insertion_point(field_release:trojan.api.SetUsersResponse.info)
  return info_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetUsersResponse::set_allocated_info(std::string* info) {
  if (info != nullptr) {
    
  } else {
    
  }
  info_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), info,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:trojan.api.SetUsersResponse.info)
}
inline std::string* SetUsersResponse::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:trojan.api.SetUsersResponse.info)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return info_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetUsersResponse::unsafe_arena_set_allocated_info(
    std::string* info) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (info != nullptr) {
    
  } else {
    
  }
  info_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      info, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trojan.api.SetUsersResponse.info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace trojan

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::trojan::api::SetUsersRequest_Operation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trojan::api::SetUsersRequest_Operation>() {
  return ::trojan::api::SetUsersRequest_Operation_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_trojangoapi_2eproto
